from typing import List
import docking
import docking.actions
import docking.widgets.table
import java.awt
import java.awt.dnd
import java.awt.event
import java.awt.im
import java.awt.image
import java.awt.print
import java.beans
import java.io
import java.lang
import java.text
import java.util
import javax.accessibility
import javax.print
import javax.print.attribute
import javax.swing
import javax.swing.border
import javax.swing.event
import javax.swing.plaf
import javax.swing.table


class FVTable(docking.widgets.table.GTable, java.awt.event.MouseMotionListener, java.awt.event.MouseListener):
    """
    The table that backs the FileViewer window. It is responsible for displaying
     Chunk instances.
    """





    def __init__(self, reader: ghidra.framework.main.logviewer.model.ChunkReader, viewportUtility: ghidra.framework.main.logviewer.ui.ViewportUtility, model: ghidra.framework.main.logviewer.model.ChunkModel, eventListener: ghidra.framework.main.logviewer.event.FVEventListener):
        """
        Ctor.
        @param reader
        @param viewportUtility
        @param model
        @param eventListener
        """
        ...



    def action(self, __a0: java.awt.Event, __a1: object) -> bool: ...

    @overload
    def add(self, __a0: java.awt.Component) -> java.awt.Component: ...

    @overload
    def add(self, __a0: java.awt.PopupMenu) -> None: ...

    @overload
    def add(self, __a0: java.awt.Component, __a1: int) -> java.awt.Component: ...

    @overload
    def add(self, __a0: unicode, __a1: java.awt.Component) -> java.awt.Component: ...

    @overload
    def add(self, __a0: java.awt.Component, __a1: object) -> None: ...

    @overload
    def add(self, __a0: java.awt.Component, __a1: object, __a2: int) -> None: ...

    def addAncestorListener(self, __a0: javax.swing.event.AncestorListener) -> None: ...

    def addColumn(self, __a0: javax.swing.table.TableColumn) -> None: ...

    def addColumnSelectionInterval(self, __a0: int, __a1: int) -> None: ...

    def addComponentListener(self, __a0: java.awt.event.ComponentListener) -> None: ...

    def addContainerListener(self, __a0: java.awt.event.ContainerListener) -> None: ...

    def addFocusListener(self, __a0: java.awt.event.FocusListener) -> None: ...

    def addHierarchyBoundsListener(self, __a0: java.awt.event.HierarchyBoundsListener) -> None: ...

    def addHierarchyListener(self, __a0: java.awt.event.HierarchyListener) -> None: ...

    def addInputMethodListener(self, __a0: java.awt.event.InputMethodListener) -> None: ...

    def addKeyListener(self, __a0: java.awt.event.KeyListener) -> None: ...

    def addMouseListener(self, __a0: java.awt.event.MouseListener) -> None: ...

    def addMouseMotionListener(self, __a0: java.awt.event.MouseMotionListener) -> None: ...

    def addMouseWheelListener(self, __a0: java.awt.event.MouseWheelListener) -> None: ...

    def addNotify(self) -> None: ...

    @overload
    def addPropertyChangeListener(self, __a0: java.beans.PropertyChangeListener) -> None: ...

    @overload
    def addPropertyChangeListener(self, __a0: unicode, __a1: java.beans.PropertyChangeListener) -> None: ...

    def addRow(self, row: unicode) -> None:
        """
        Adds the given row to the table.
        @param row
        """
        ...

    def addRowSelectionInterval(self, __a0: int, __a1: int) -> None: ...

    def addRows(self, __a0: List[object]) -> None: ...

    def addVetoableChangeListener(self, __a0: java.beans.VetoableChangeListener) -> None: ...

    def applyComponentOrientation(self, __a0: java.awt.ComponentOrientation) -> None: ...

    def areActionsEnabled(self) -> bool:
        """
        Returns true if key strokes are used to trigger actions.

         <p>This method has a relationship with {@link #setAutoLookupColumn(int)}.  If this method
         returns <code>true</code>, then the auto-lookup feature is disabled.  If this method
         returns <code>false</code>, then the auto-lookup may or may not be enabled.
        @return true if key strokes are used to trigger actions
        @see #setActionsEnabled(boolean)
        @see #setAutoLookupColumn(int)
        """
        ...

    def areFocusTraversalKeysSet(self, __a0: int) -> bool: ...

    def changeSelection(self, __a0: int, __a1: int, __a2: bool, __a3: bool) -> None: ...

    @overload
    def checkImage(self, __a0: java.awt.Image, __a1: java.awt.image.ImageObserver) -> int: ...

    @overload
    def checkImage(self, __a0: java.awt.Image, __a1: int, __a2: int, __a3: java.awt.image.ImageObserver) -> int: ...

    def clear(self) -> None:
        """
        Removes all rows from the table model.
        """
        ...

    def clearSelection(self) -> None: ...

    def columnAdded(self, e: javax.swing.event.TableColumnModelEvent) -> None: ...

    def columnAtPoint(self, __a0: java.awt.Point) -> int: ...

    def columnMarginChanged(self, __a0: javax.swing.event.ChangeEvent) -> None: ...

    def columnMoved(self, __a0: javax.swing.event.TableColumnModelEvent) -> None: ...

    def columnRemoved(self, e: javax.swing.event.TableColumnModelEvent) -> None: ...

    def columnSelectionChanged(self, __a0: javax.swing.event.ListSelectionEvent) -> None: ...

    def computeVisibleRect(self, __a0: java.awt.Rectangle) -> None: ...

    @overload
    def contains(self, __a0: java.awt.Point) -> bool: ...

    @overload
    def contains(self, __a0: int, __a1: int) -> bool: ...

    def convertColumnIndexToModel(self, __a0: int) -> int: ...

    def convertColumnIndexToView(self, __a0: int) -> int: ...

    def convertRowIndexToModel(self, __a0: int) -> int: ...

    def convertRowIndexToView(self, __a0: int) -> int: ...

    def countComponents(self) -> int: ...

    def createDefaultColumnsFromModel(self) -> None:
        """
        Overridden in order to set the column header renderer on newly created columns.
        @see javax.swing.JTable#createDefaultColumnsFromModel()
        """
        ...

    @overload
    def createImage(self, __a0: java.awt.image.ImageProducer) -> java.awt.Image: ...

    @overload
    def createImage(self, __a0: int, __a1: int) -> java.awt.Image: ...

    @staticmethod
    def createScrollPaneForTable(__a0: javax.swing.JTable) -> javax.swing.JScrollPane: ...

    @staticmethod
    def createSharedActions(tool: docking.Tool, toolActions: docking.actions.ToolActions, owner: unicode) -> None: ...

    def createToolTip(self) -> javax.swing.JToolTip: ...

    @overload
    def createVolatileImage(self, __a0: int, __a1: int) -> java.awt.image.VolatileImage: ...

    @overload
    def createVolatileImage(self, __a0: int, __a1: int, __a2: java.awt.ImageCapabilities) -> java.awt.image.VolatileImage: ...

    def decrementAndAddSelection(self, rows: int) -> None:
        """
        Decrements the selection by the number of rows given, and adds the new rows to the
         selection.
        @param rows
        """
        ...

    def decrementSelection(self, rows: int) -> None:
        """
        Moves the table selection up by the number of rows specified, ensuring that selection
         does not go beyond the beginning of the file.
        @param rows
        """
        ...

    def deliverEvent(self, __a0: java.awt.Event) -> None: ...

    def disable(self) -> None: ...

    def dispatchEvent(self, __a0: java.awt.AWTEvent) -> None: ...

    def dispose(self) -> None:
        """
        Call this when the table will no longer be used
        """
        ...

    def doLayout(self) -> None: ...

    @overload
    def editCellAt(self, row: int, column: int) -> bool:
        """
        If you just begin typing into an editable cell in
         a JTable, then the cell editor will be displayed. However,
         the editor component will not have a focus. This
         method has been overridden to request
         focus on the editor component.
        @see javax.swing.JTable#editCellAt(int, int)
        """
        ...

    @overload
    def editCellAt(self, __a0: int, __a1: int, __a2: java.util.EventObject) -> bool: ...

    def editingCanceled(self, __a0: javax.swing.event.ChangeEvent) -> None: ...

    def editingStopped(self, __a0: javax.swing.event.ChangeEvent) -> None: ...

    @overload
    def enable(self) -> None: ...

    @overload
    def enable(self, __a0: bool) -> None: ...

    def enableInputMethods(self, __a0: bool) -> None: ...

    def equals(self, __a0: object) -> bool: ...

    @overload
    def findComponentAt(self, __a0: java.awt.Point) -> java.awt.Component: ...

    @overload
    def findComponentAt(self, __a0: int, __a1: int) -> java.awt.Component: ...

    @overload
    def firePropertyChange(self, __a0: unicode, __a1: long, __a2: long) -> None: ...

    @overload
    def firePropertyChange(self, __a0: unicode, __a1: int, __a2: int) -> None: ...

    @overload
    def firePropertyChange(self, __a0: unicode, __a1: int, __a2: int) -> None: ...

    @overload
    def firePropertyChange(self, __a0: unicode, __a1: int, __a2: int) -> None: ...

    @overload
    def firePropertyChange(self, __a0: unicode, __a1: int, __a2: int) -> None: ...

    @overload
    def firePropertyChange(self, __a0: unicode, __a1: float, __a2: float) -> None: ...

    @overload
    def firePropertyChange(self, __a0: unicode, __a1: float, __a2: float) -> None: ...

    @overload
    def firePropertyChange(self, __a0: unicode, __a1: bool, __a2: bool) -> None: ...

    def getAccessibleContext(self) -> javax.accessibility.AccessibleContext: ...

    def getActionForKeyStroke(self, __a0: javax.swing.KeyStroke) -> java.awt.event.ActionListener: ...

    def getActionMap(self) -> javax.swing.ActionMap: ...

    def getAlignmentX(self) -> float: ...

    def getAlignmentY(self) -> float: ...

    def getAncestorListeners(self) -> List[javax.swing.event.AncestorListener]: ...

    def getAutoCreateColumnsFromModel(self) -> bool: ...

    def getAutoCreateRowSorter(self) -> bool: ...

    def getAutoResizeMode(self) -> int: ...

    def getAutoscrolls(self) -> bool: ...

    def getBackground(self) -> java.awt.Color: ...

    def getBaseline(self, __a0: int, __a1: int) -> int: ...

    def getBaselineResizeBehavior(self) -> java.awt.Component.BaselineResizeBehavior: ...

    def getBorder(self) -> javax.swing.border.Border: ...

    @overload
    def getBounds(self) -> java.awt.Rectangle: ...

    @overload
    def getBounds(self, __a0: java.awt.Rectangle) -> java.awt.Rectangle: ...

    @overload
    def getCellEditor(self) -> javax.swing.table.TableCellEditor: ...

    @overload
    def getCellEditor(self, __a0: int, __a1: int) -> javax.swing.table.TableCellEditor: ...

    def getCellRect(self, __a0: int, __a1: int, __a2: bool) -> java.awt.Rectangle: ...

    def getCellRenderer(self, row: int, col: int) -> javax.swing.table.TableCellRenderer: ...

    def getCellRendererOverride(self, row: int, col: int) -> javax.swing.table.TableCellRenderer:
        """
        Performs custom work to locate renderers for special table model types.  This method
         allows clients to bypass the {@link #getCellRenderer(int, int)}, which is sometimes
         overridden by subclasses to return a hard-coded renderer.  In that case, some clients
         still want a way to perform normal cell renderer lookup.
        @param row the row
        @param col the column
        @return the cell renderer
        """
        ...

    def getCellSelectionEnabled(self) -> bool: ...

    def getClass(self) -> java.lang.Class: ...

    def getClientProperty(self, __a0: object) -> object: ...

    def getColorModel(self) -> java.awt.image.ColorModel: ...

    def getColumn(self, __a0: object) -> javax.swing.table.TableColumn: ...

    def getColumnClass(self, __a0: int) -> java.lang.Class: ...

    def getColumnCount(self) -> int: ...

    def getColumnModel(self) -> javax.swing.table.TableColumnModel: ...

    def getColumnName(self, __a0: int) -> unicode: ...

    def getColumnSelectionAllowed(self) -> bool: ...

    def getComponent(self, __a0: int) -> java.awt.Component: ...

    @overload
    def getComponentAt(self, __a0: java.awt.Point) -> java.awt.Component: ...

    @overload
    def getComponentAt(self, __a0: int, __a1: int) -> java.awt.Component: ...

    def getComponentCount(self) -> int: ...

    def getComponentListeners(self) -> List[java.awt.event.ComponentListener]: ...

    def getComponentOrientation(self) -> java.awt.ComponentOrientation: ...

    def getComponentPopupMenu(self) -> javax.swing.JPopupMenu: ...

    def getComponentZOrder(self, __a0: java.awt.Component) -> int: ...

    def getComponents(self) -> List[java.awt.Component]: ...

    def getConditionForKeyStroke(self, __a0: javax.swing.KeyStroke) -> int: ...

    def getConfigurableColumnTableModel(self) -> docking.widgets.table.ConfigurableColumnTableModel:
        """
        Returns the underlying ConfigurableColumnTableModel if one is in-use
        @return the underlying ConfigurableColumnTableModel if one is in-use
        """
        ...

    def getContainerListeners(self) -> List[java.awt.event.ContainerListener]: ...

    def getCursor(self) -> java.awt.Cursor: ...

    def getDebugGraphicsOptions(self) -> int: ...

    def getDefaultEditor(self, __a0: java.lang.Class) -> javax.swing.table.TableCellEditor: ...

    @staticmethod
    def getDefaultLocale() -> java.util.Locale: ...

    def getDefaultRenderer(self, columnClass: java.lang.Class) -> javax.swing.table.TableCellRenderer: ...

    def getDragEnabled(self) -> bool: ...

    def getDropLocation(self) -> javax.swing.JTable.DropLocation: ...

    def getDropMode(self) -> javax.swing.DropMode: ...

    def getDropTarget(self) -> java.awt.dnd.DropTarget: ...

    def getEditingColumn(self) -> int: ...

    def getEditingRow(self) -> int: ...

    def getEditorComponent(self) -> java.awt.Component: ...

    def getFillsViewportHeight(self) -> bool: ...

    def getFocusCycleRootAncestor(self) -> java.awt.Container: ...

    def getFocusListeners(self) -> List[java.awt.event.FocusListener]: ...

    def getFocusTraversalKeys(self, __a0: int) -> java.util.Set: ...

    def getFocusTraversalKeysEnabled(self) -> bool: ...

    def getFocusTraversalPolicy(self) -> java.awt.FocusTraversalPolicy: ...

    def getFont(self) -> java.awt.Font: ...

    def getFontMetrics(self, __a0: java.awt.Font) -> java.awt.FontMetrics: ...

    def getForeground(self) -> java.awt.Color: ...

    def getGraphics(self) -> java.awt.Graphics: ...

    def getGraphicsConfiguration(self) -> java.awt.GraphicsConfiguration: ...

    def getGridColor(self) -> java.awt.Color: ...

    def getHeight(self) -> int: ...

    def getHierarchyBoundsListeners(self) -> List[java.awt.event.HierarchyBoundsListener]: ...

    def getHierarchyListeners(self) -> List[java.awt.event.HierarchyListener]: ...

    def getIgnoreRepaint(self) -> bool: ...

    def getInheritsPopupMenu(self) -> bool: ...

    def getInputContext(self) -> java.awt.im.InputContext: ...

    @overload
    def getInputMap(self) -> javax.swing.InputMap: ...

    @overload
    def getInputMap(self, __a0: int) -> javax.swing.InputMap: ...

    def getInputMethodListeners(self) -> List[java.awt.event.InputMethodListener]: ...

    def getInputMethodRequests(self) -> java.awt.im.InputMethodRequests: ...

    def getInputVerifier(self) -> javax.swing.InputVerifier: ...

    @overload
    def getInsets(self) -> java.awt.Insets: ...

    @overload
    def getInsets(self, __a0: java.awt.Insets) -> java.awt.Insets: ...

    def getIntercellSpacing(self) -> java.awt.Dimension: ...

    def getKeyListeners(self) -> List[java.awt.event.KeyListener]: ...

    def getLayout(self) -> java.awt.LayoutManager: ...

    def getListeners(self, __a0: java.lang.Class) -> List[java.util.EventListener]: ...

    def getLocale(self) -> java.util.Locale: ...

    @overload
    def getLocation(self) -> java.awt.Point: ...

    @overload
    def getLocation(self, __a0: java.awt.Point) -> java.awt.Point: ...

    def getLocationOnScreen(self) -> java.awt.Point: ...

    def getMaximumSize(self) -> java.awt.Dimension: ...

    def getMinimumSize(self) -> java.awt.Dimension: ...

    def getModel(self) -> javax.swing.table.TableModel: ...

    def getMouseListeners(self) -> List[java.awt.event.MouseListener]: ...

    def getMouseMotionListeners(self) -> List[java.awt.event.MouseMotionListener]: ...

    @overload
    def getMousePosition(self) -> java.awt.Point: ...

    @overload
    def getMousePosition(self, __a0: bool) -> java.awt.Point: ...

    def getMouseWheelListeners(self) -> List[java.awt.event.MouseWheelListener]: ...

    def getName(self) -> unicode: ...

    def getNextFocusableComponent(self) -> java.awt.Component: ...

    def getParent(self) -> java.awt.Container: ...

    def getPopupLocation(self, __a0: java.awt.event.MouseEvent) -> java.awt.Point: ...

    def getPreferenceKey(self) -> unicode:
        """
        @see #setPreferenceKey(String)
        @return the preference key
        """
        ...

    def getPreferredScrollableViewportSize(self) -> java.awt.Dimension: ...

    def getPreferredSize(self) -> java.awt.Dimension: ...

    def getPrintable(self, __a0: javax.swing.JTable.PrintMode, __a1: java.text.MessageFormat, __a2: java.text.MessageFormat) -> java.awt.print.Printable: ...

    @overload
    def getPropertyChangeListeners(self) -> List[java.beans.PropertyChangeListener]: ...

    @overload
    def getPropertyChangeListeners(self, __a0: unicode) -> List[java.beans.PropertyChangeListener]: ...

    def getRegisteredKeyStrokes(self) -> List[javax.swing.KeyStroke]: ...

    def getRootPane(self) -> javax.swing.JRootPane: ...

    def getRowCount(self) -> int: ...

    @overload
    def getRowHeight(self) -> int: ...

    @overload
    def getRowHeight(self, __a0: int) -> int: ...

    def getRowMargin(self) -> int: ...

    def getRowSelectionAllowed(self) -> bool: ...

    def getRowSorter(self) -> javax.swing.RowSorter: ...

    def getScrollableBlockIncrement(self, __a0: java.awt.Rectangle, __a1: int, __a2: int) -> int: ...

    def getScrollableTracksViewportHeight(self) -> bool: ...

    def getScrollableTracksViewportWidth(self) -> bool: ...

    def getScrollableUnitIncrement(self, __a0: java.awt.Rectangle, __a1: int, __a2: int) -> int: ...

    def getSelectedColumn(self) -> int: ...

    def getSelectedColumnCount(self) -> int: ...

    def getSelectedColumns(self) -> List[int]: ...

    def getSelectedRow(self) -> int: ...

    def getSelectedRowCount(self) -> int: ...

    def getSelectedRows(self) -> List[int]: ...

    def getSelectionBackground(self) -> java.awt.Color: ...

    def getSelectionForeground(self) -> java.awt.Color: ...

    def getSelectionManager(self) -> docking.widgets.table.SelectionManager:
        """
        Returns the {@link SelectionManager} in use by this GTable.  <code>null</code> is returned
         if the user has installed their own {@link ListSelectionModel}.
        @return the selection manager
        """
        ...

    def getSelectionModel(self) -> javax.swing.ListSelectionModel: ...

    def getShowHorizontalLines(self) -> bool: ...

    def getShowVerticalLines(self) -> bool: ...

    @overload
    def getSize(self) -> java.awt.Dimension: ...

    @overload
    def getSize(self, __a0: java.awt.Dimension) -> java.awt.Dimension: ...

    def getSurrendersFocusOnKeystroke(self) -> bool: ...

    def getTableColumnPopupMenu(self, columnIndex: int) -> javax.swing.JPopupMenu: ...

    def getTableHeader(self) -> javax.swing.table.JTableHeader: ...

    def getToolTipLocation(self, __a0: java.awt.event.MouseEvent) -> java.awt.Point: ...

    @overload
    def getToolTipText(self) -> unicode: ...

    @overload
    def getToolTipText(self, e: java.awt.event.MouseEvent) -> unicode:
        """
        @see javax.swing.JComponent#getToolTipText(java.awt.event.MouseEvent)
        """
        ...

    def getToolkit(self) -> java.awt.Toolkit: ...

    def getTopLevelAncestor(self) -> java.awt.Container: ...

    def getTransferHandler(self) -> javax.swing.TransferHandler: ...

    def getTreeLock(self) -> object: ...

    def getUI(self) -> javax.swing.plaf.ComponentUI: ...

    def getUIClassID(self) -> unicode: ...

    def getUpdateSelectionOnSort(self) -> bool: ...

    def getValueAt(self, row: int, column: int) -> object: ...

    def getVerifyInputWhenFocusTarget(self) -> bool: ...

    def getVetoableChangeListeners(self) -> List[java.beans.VetoableChangeListener]: ...

    def getVisibleRect(self) -> java.awt.Rectangle: ...

    def getWidth(self) -> int: ...

    def getX(self) -> int: ...

    def getY(self) -> int: ...

    def gotFocus(self, __a0: java.awt.Event, __a1: object) -> bool: ...

    def grabFocus(self) -> None: ...

    def handleEvent(self, __a0: java.awt.Event) -> bool: ...

    def hasFocus(self) -> bool: ...

    def hashCode(self) -> int: ...

    def hide(self) -> None: ...

    def imageUpdate(self, __a0: java.awt.Image, __a1: int, __a2: int, __a3: int, __a4: int, __a5: int) -> bool: ...

    def incrementAndAddSelection(self, rows: int) -> None:
        """
        Increments the selection by the given number of rows, but doesn't affect any previously
         selected rows. This is typically called when selecting while dragging.
        @param rows
        """
        ...

    def incrementSelection(self, rows: int) -> None:
        """
        Moves the table selection down by the number of rows specified, ensuring that selection
         does not go beyond the bounds of the file.
        @param rows
        """
        ...

    def inside(self, __a0: int, __a1: int) -> bool: ...

    def invalidate(self) -> None: ...

    def isAncestorOf(self, __a0: java.awt.Component) -> bool: ...

    def isBackgroundSet(self) -> bool: ...

    def isCellEditable(self, __a0: int, __a1: int) -> bool: ...

    def isCellSelected(self, __a0: int, __a1: int) -> bool: ...

    def isColumnHeaderPopupEnabled(self) -> bool: ...

    def isColumnSelected(self, __a0: int) -> bool: ...

    def isCursorSet(self) -> bool: ...

    def isDisplayable(self) -> bool: ...

    def isDoubleBuffered(self) -> bool: ...

    def isEditing(self) -> bool: ...

    def isEnabled(self) -> bool: ...

    @overload
    def isFocusCycleRoot(self) -> bool: ...

    @overload
    def isFocusCycleRoot(self, __a0: java.awt.Container) -> bool: ...

    def isFocusOwner(self) -> bool: ...

    def isFocusTraversable(self) -> bool: ...

    def isFocusTraversalPolicyProvider(self) -> bool: ...

    def isFocusTraversalPolicySet(self) -> bool: ...

    def isFocusable(self) -> bool: ...

    def isFontSet(self) -> bool: ...

    def isForegroundSet(self) -> bool: ...

    def isLightweight(self) -> bool: ...

    @staticmethod
    def isLightweightComponent(__a0: java.awt.Component) -> bool: ...

    def isManagingFocus(self) -> bool: ...

    def isMaximumSizeSet(self) -> bool: ...

    def isMinimumSizeSet(self) -> bool: ...

    def isOpaque(self) -> bool: ...

    def isOptimizedDrawingEnabled(self) -> bool: ...

    def isPaintingForPrint(self) -> bool: ...

    def isPaintingTile(self) -> bool: ...

    def isPreferredSizeSet(self) -> bool: ...

    def isRequestFocusEnabled(self) -> bool: ...

    def isRowSelected(self, __a0: int) -> bool: ...

    def isShowing(self) -> bool: ...

    def isValid(self) -> bool: ...

    def isValidateRoot(self) -> bool: ...

    def isVisible(self) -> bool: ...

    def keyDown(self, __a0: java.awt.Event, __a1: int) -> bool: ...

    def keyUp(self, __a0: java.awt.Event, __a1: int) -> bool: ...

    @overload
    def list(self) -> None: ...

    @overload
    def list(self, __a0: java.io.PrintStream) -> None: ...

    @overload
    def list(self, __a0: java.io.PrintWriter) -> None: ...

    @overload
    def list(self, __a0: java.io.PrintStream, __a1: int) -> None: ...

    @overload
    def list(self, __a0: java.io.PrintWriter, __a1: int) -> None: ...

    def locate(self, __a0: int, __a1: int) -> java.awt.Component: ...

    def location(self) -> java.awt.Point: ...

    def lostFocus(self, __a0: java.awt.Event, __a1: object) -> bool: ...

    def mouseClicked(self, e: java.awt.event.MouseEvent) -> None: ...

    def mouseDown(self, __a0: java.awt.Event, __a1: int, __a2: int) -> bool: ...

    def mouseDrag(self, __a0: java.awt.Event, __a1: int, __a2: int) -> bool: ...

    def mouseDragged(self, e: java.awt.event.MouseEvent) -> None: ...

    def mouseEnter(self, __a0: java.awt.Event, __a1: int, __a2: int) -> bool: ...

    def mouseEntered(self, e: java.awt.event.MouseEvent) -> None: ...

    def mouseExit(self, __a0: java.awt.Event, __a1: int, __a2: int) -> bool: ...

    def mouseExited(self, e: java.awt.event.MouseEvent) -> None: ...

    def mouseMove(self, __a0: java.awt.Event, __a1: int, __a2: int) -> bool: ...

    def mouseMoved(self, e: java.awt.event.MouseEvent) -> None: ...

    def mousePressed(self, e: java.awt.event.MouseEvent) -> None: ...

    def mouseReleased(self, e: java.awt.event.MouseEvent) -> None: ...

    def mouseUp(self, __a0: java.awt.Event, __a1: int, __a2: int) -> bool: ...

    def move(self, __a0: int, __a1: int) -> None: ...

    def moveColumn(self, __a0: int, __a1: int) -> None: ...

    def nextFocus(self) -> None: ...

    def notify(self) -> None: ...

    def notifyAll(self) -> None: ...

    def notifyTableChanged(self, event: javax.swing.event.TableModelEvent) -> None:
        """
        A method that allows clients to signal to this GTable and its internals that the table
         model has changed.  Usually, {@link #tableChanged(TableModelEvent)} is called, but clients
         alter the table, but do not do so through the model.  In this case, they need a way to
         signal to the table that the model has been updated.
        @param event the event for the change
        """
        ...

    def paint(self, __a0: java.awt.Graphics) -> None: ...

    def paintAll(self, __a0: java.awt.Graphics) -> None: ...

    def paintComponents(self, __a0: java.awt.Graphics) -> None: ...

    @overload
    def paintImmediately(self, __a0: java.awt.Rectangle) -> None: ...

    @overload
    def paintImmediately(self, __a0: int, __a1: int, __a2: int, __a3: int) -> None: ...

    def postEvent(self, __a0: java.awt.Event) -> bool: ...

    def prepareEditor(self, __a0: javax.swing.table.TableCellEditor, __a1: int, __a2: int) -> java.awt.Component: ...

    @overload
    def prepareImage(self, __a0: java.awt.Image, __a1: java.awt.image.ImageObserver) -> bool: ...

    @overload
    def prepareImage(self, __a0: java.awt.Image, __a1: int, __a2: int, __a3: java.awt.image.ImageObserver) -> bool: ...

    def prepareRenderer(self, renderer: javax.swing.table.TableCellRenderer, row: int, column: int) -> java.awt.Component:
        """
        Adjusts the column widths to be at least as wide as the widest cell.  This is required
         for horizontal scrolling to work properly.
        """
        ...

    @overload
    def print(self) -> bool: ...

    @overload
    def print(self, __a0: java.awt.Graphics) -> None: ...

    @overload
    def print(self, __a0: javax.swing.JTable.PrintMode) -> bool: ...

    @overload
    def print(self, __a0: javax.swing.JTable.PrintMode, __a1: java.text.MessageFormat, __a2: java.text.MessageFormat) -> bool: ...

    @overload
    def print(self, __a0: javax.swing.JTable.PrintMode, __a1: java.text.MessageFormat, __a2: java.text.MessageFormat, __a3: bool, __a4: javax.print.attribute.PrintRequestAttributeSet, __a5: bool) -> bool: ...

    @overload
    def print(self, __a0: javax.swing.JTable.PrintMode, __a1: java.text.MessageFormat, __a2: java.text.MessageFormat, __a3: bool, __a4: javax.print.attribute.PrintRequestAttributeSet, __a5: bool, __a6: javax.print.PrintService) -> bool: ...

    def printAll(self, __a0: java.awt.Graphics) -> None: ...

    def printComponents(self, __a0: java.awt.Graphics) -> None: ...

    def putClientProperty(self, __a0: object, __a1: object) -> None: ...

    @overload
    def registerKeyboardAction(self, __a0: java.awt.event.ActionListener, __a1: javax.swing.KeyStroke, __a2: int) -> None: ...

    @overload
    def registerKeyboardAction(self, __a0: java.awt.event.ActionListener, __a1: unicode, __a2: javax.swing.KeyStroke, __a3: int) -> None: ...

    @overload
    def remove(self, __a0: int) -> None: ...

    @overload
    def remove(self, __a0: java.awt.Component) -> None: ...

    @overload
    def remove(self, __a0: java.awt.MenuComponent) -> None: ...

    def removeAll(self) -> None: ...

    def removeAncestorListener(self, __a0: javax.swing.event.AncestorListener) -> None: ...

    def removeColumn(self, __a0: javax.swing.table.TableColumn) -> None: ...

    def removeColumnSelectionInterval(self, __a0: int, __a1: int) -> None: ...

    def removeComponentListener(self, __a0: java.awt.event.ComponentListener) -> None: ...

    def removeContainerListener(self, __a0: java.awt.event.ContainerListener) -> None: ...

    def removeEditor(self) -> None: ...

    def removeFocusListener(self, __a0: java.awt.event.FocusListener) -> None: ...

    def removeHierarchyBoundsListener(self, __a0: java.awt.event.HierarchyBoundsListener) -> None: ...

    def removeHierarchyListener(self, __a0: java.awt.event.HierarchyListener) -> None: ...

    def removeInputMethodListener(self, __a0: java.awt.event.InputMethodListener) -> None: ...

    def removeKeyListener(self, __a0: java.awt.event.KeyListener) -> None: ...

    def removeMouseListener(self, __a0: java.awt.event.MouseListener) -> None: ...

    def removeMouseMotionListener(self, __a0: java.awt.event.MouseMotionListener) -> None: ...

    def removeMouseWheelListener(self, __a0: java.awt.event.MouseWheelListener) -> None: ...

    def removeNotify(self) -> None: ...

    @overload
    def removePropertyChangeListener(self, __a0: java.beans.PropertyChangeListener) -> None: ...

    @overload
    def removePropertyChangeListener(self, __a0: unicode, __a1: java.beans.PropertyChangeListener) -> None: ...

    def removeRowSelectionInterval(self, __a0: int, __a1: int) -> None: ...

    def removeVetoableChangeListener(self, __a0: java.beans.VetoableChangeListener) -> None: ...

    @overload
    def repaint(self) -> None: ...

    @overload
    def repaint(self, __a0: long) -> None: ...

    @overload
    def repaint(self, __a0: java.awt.Rectangle) -> None: ...

    @overload
    def repaint(self, __a0: int, __a1: int, __a2: int, __a3: int) -> None: ...

    @overload
    def repaint(self, __a0: long, __a1: int, __a2: int, __a3: int, __a4: int) -> None: ...

    def requestDefaultFocus(self) -> bool: ...

    @overload
    def requestFocus(self) -> None: ...

    @overload
    def requestFocus(self, __a0: bool) -> bool: ...

    @overload
    def requestFocus(self, __a0: java.awt.event.FocusEvent.Cause) -> None: ...

    @overload
    def requestFocusInWindow(self) -> bool: ...

    @overload
    def requestFocusInWindow(self, __a0: java.awt.event.FocusEvent.Cause) -> bool: ...

    def resetKeyboardActions(self) -> None: ...

    def reshape(self, __a0: int, __a1: int, __a2: int, __a3: int) -> None: ...

    @overload
    def resize(self, __a0: java.awt.Dimension) -> None: ...

    @overload
    def resize(self, __a0: int, __a1: int) -> None: ...

    def restoreSelection(self) -> None:
        """
        Set any previously selected table rows to a selected state. This should be called any
         time a chunk is read into the table.

         Note: This is critically important when the user has selected a row, then scrolled such that
         the selected row is in a chunk that has been swapped out and is no longer in the table. When
         that chunk is scrolled back into view, this will restore the selection.

         Note2: If there is a range of selected values and the table is somewhere in the middle of
         that range, just select the entire table.
        """
        ...

    def revalidate(self) -> None: ...

    def rowAtPoint(self, __a0: java.awt.Point) -> int: ...

    def savePreferences(self) -> None:
        """
        Signals that the preferences of this table (visible columns, sort order, etc.) should be
         saved.  Most clients never need to call this method, as changes are saved for free when
         the user manipulates columns.  However, sometimes the client can change the state of the
         columns programmatically, which is not guaranteed to get saved; for example, setting
         the sort state of a sorted table model programmatically will not get saved.
        """
        ...

    def scrollRectToVisible(self, __a0: java.awt.Rectangle) -> None: ...

    def scrollToSelectedRow(self) -> None: ...

    def selectAll(self) -> None: ...

    @overload
    def selectRow(self, row: int) -> None:
        """
        Selects the given row.  This is a convenience method for
         {@link #setRowSelectionInterval(int, int)}.
        @param row The row to select
        """
        ...

    @overload
    def selectRow(self, event: java.awt.event.MouseEvent) -> bool:
        """
        Selects the row under the given mouse point.  This method is useful when the user
         triggers a popup mouse action and you would like to have the table select that row if it
         is not already selected.  This allows you to guarantee that there is always a selection
         when the user triggers a popup menu.
        @param event The event that triggered the popup menu
        @return true if the row is selected or was already selected.
        """
        ...

    def setActionMap(self, __a0: javax.swing.ActionMap) -> None: ...

    def setActionsEnabled(self, b: bool) -> None:
        """
        Enables the keyboard actions to pass through this table and up the component hierarchy.
         Specifically, passing true to this method allows unmodified keystrokes to work
         in the tool when this table is focused.  Modified keystrokes, like <code>
         Ctrl-C</code>, will work at all times.   Finally, if true is passed to this
         method, then the {@link #setAutoLookupColumn(int) auto lookup} feature is
         disabled.

         <p>The default state is for actions to be disabled.
        @param b true allows keyboard actions to pass up the component hierarchy.
        """
        ...

    def setAlignmentX(self, __a0: float) -> None: ...

    def setAlignmentY(self, __a0: float) -> None: ...

    def setAutoCreateColumnsFromModel(self, __a0: bool) -> None: ...

    def setAutoCreateRowSorter(self, __a0: bool) -> None: ...

    def setAutoEditEnabled(self, allowAutoEdit: bool) -> None:
        """
        Enables or disables auto-edit.  When enabled, the user can start typing to trigger an
         edit of an editable table cell.
        @param allowAutoEdit true for auto-editing
        """
        ...

    def setAutoLookupColumn(self, lookupColumn: int) -> None:
        """
        Sets the column in which auto-lookup will be enabled.

         <p>Note: calling this method with a valid column index will disable key binding support
         of actions.  See {@link #setActionsEnabled(boolean)}.  Passing an invalid column index
         will disable the auto-lookup feature.
        @param lookupColumn the column in which auto-lookup will be enabled
        """
        ...

    def setAutoLookupTimeout(self, timeout: long) -> None:
        """
        Sets the delay between keystrokes after which each keystroke is considered a new lookup
        @param timeout the timeout
        @see #setAutoLookupColumn(int)
        @see AutoLookup#KEY_TYPING_TIMEOUT
        """
        ...

    def setAutoResizeMode(self, __a0: int) -> None: ...

    def setAutoscrolls(self, __a0: bool) -> None: ...

    def setBackground(self, __a0: java.awt.Color) -> None: ...

    def setBorder(self, __a0: javax.swing.border.Border) -> None: ...

    @overload
    def setBounds(self, __a0: java.awt.Rectangle) -> None: ...

    @overload
    def setBounds(self, __a0: int, __a1: int, __a2: int, __a3: int) -> None: ...

    def setCellEditor(self, __a0: javax.swing.table.TableCellEditor) -> None: ...

    def setCellSelectionEnabled(self, __a0: bool) -> None: ...

    def setColumnHeaderPopupEnabled(self, enabled: bool) -> None: ...

    def setColumnModel(self, columnModel: javax.swing.table.TableColumnModel) -> None: ...

    def setColumnSelectionAllowed(self, __a0: bool) -> None: ...

    def setColumnSelectionInterval(self, __a0: int, __a1: int) -> None: ...

    def setComponentOrientation(self, __a0: java.awt.ComponentOrientation) -> None: ...

    def setComponentPopupMenu(self, __a0: javax.swing.JPopupMenu) -> None: ...

    def setComponentZOrder(self, __a0: java.awt.Component, __a1: int) -> None: ...

    def setCursor(self, __a0: java.awt.Cursor) -> None: ...

    def setDebugGraphicsOptions(self, __a0: int) -> None: ...

    def setDefaultEditor(self, __a0: java.lang.Class, __a1: javax.swing.table.TableCellEditor) -> None: ...

    @staticmethod
    def setDefaultLocale(__a0: java.util.Locale) -> None: ...

    def setDefaultRenderer(self, __a0: java.lang.Class, __a1: javax.swing.table.TableCellRenderer) -> None: ...

    def setDoubleBuffered(self, __a0: bool) -> None: ...

    def setDragEnabled(self, __a0: bool) -> None: ...

    def setDropMode(self, __a0: javax.swing.DropMode) -> None: ...

    def setDropTarget(self, __a0: java.awt.dnd.DropTarget) -> None: ...

    def setEditingColumn(self, __a0: int) -> None: ...

    def setEditingRow(self, __a0: int) -> None: ...

    def setEnabled(self, __a0: bool) -> None: ...

    def setFillsViewportHeight(self, __a0: bool) -> None: ...

    def setFocusCycleRoot(self, __a0: bool) -> None: ...

    def setFocusTraversalKeys(self, __a0: int, __a1: java.util.Set) -> None: ...

    def setFocusTraversalKeysEnabled(self, __a0: bool) -> None: ...

    def setFocusTraversalPolicy(self, __a0: java.awt.FocusTraversalPolicy) -> None: ...

    def setFocusTraversalPolicyProvider(self, __a0: bool) -> None: ...

    def setFocusable(self, __a0: bool) -> None: ...

    def setFont(self, __a0: java.awt.Font) -> None: ...

    def setForeground(self, __a0: java.awt.Color) -> None: ...

    def setGridColor(self, __a0: java.awt.Color) -> None: ...

    def setHTMLRenderingEnabled(self, enable: bool) -> None:
        """
        Enables and disables the rendering of HTML content in this table.  If enabled, this table
         will:
         <ul>
             <li>Wrap tooltip text content with an &lt;html&gt; tag so that it is possible for
                 the content to be formatted in a manner that is easier for the user read, and</li>
             <li>Enable any <code>default</code> {@link GTableCellRenderer} instances to render
                 HTML content, which they do not do by default.</li>
         </ul>
         <p>
         As mentioned above, this class only enables/disables the HTML rendering on
         {@link GTableCellRenderer} instances that were created by this class (or subclasses)
         during initialization in {@link #initDefaultRenderers()} and that have been added to the
         {@link #defaultGTableRendererList}.  If users of this class have changed or added new
         renderers, then those renderers will not be changed by calling this method.  Typically,
         this method should be called just after created an instance of this class, which will work
         as described by this method.
         <p>
         HTML rendering is disabled by default.
        @param enable true to enable HTML rendering; false to disable it
        """
        ...

    def setIgnoreRepaint(self, __a0: bool) -> None: ...

    def setInheritsPopupMenu(self, __a0: bool) -> None: ...

    def setInputMap(self, __a0: int, __a1: javax.swing.InputMap) -> None: ...

    def setInputVerifier(self, __a0: javax.swing.InputVerifier) -> None: ...

    def setIntercellSpacing(self, __a0: java.awt.Dimension) -> None: ...

    def setLayout(self, __a0: java.awt.LayoutManager) -> None: ...

    def setLocale(self, __a0: java.util.Locale) -> None: ...

    @overload
    def setLocation(self, __a0: java.awt.Point) -> None: ...

    @overload
    def setLocation(self, __a0: int, __a1: int) -> None: ...

    def setMaximumSize(self, __a0: java.awt.Dimension) -> None: ...

    def setMinimumSize(self, __a0: java.awt.Dimension) -> None: ...

    def setMixingCutoutShape(self, __a0: java.awt.Shape) -> None: ...

    def setModel(self, dataModel: javax.swing.table.TableModel) -> None: ...

    def setMouseDragging(self, isMouseDragging: bool) -> None: ...

    def setName(self, __a0: unicode) -> None: ...

    def setNextFocusableComponent(self, __a0: java.awt.Component) -> None: ...

    def setOpaque(self, __a0: bool) -> None: ...

    def setPreferenceKey(self, preferenceKey: unicode) -> None:
        """
        Sets the key for saving and restoring column configuration state.  Use this if you have
         multiple instances of a table and you want different column settings for each instance.
        @param preferenceKey the unique string to use a key for this instance.
        """
        ...

    def setPreferredScrollableViewportSize(self, __a0: java.awt.Dimension) -> None: ...

    def setPreferredSize(self, __a0: java.awt.Dimension) -> None: ...

    def setRequestFocusEnabled(self, __a0: bool) -> None: ...

    @overload
    def setRowHeight(self, height: int) -> None: ...

    @overload
    def setRowHeight(self, __a0: int, __a1: int) -> None: ...

    def setRowMargin(self, __a0: int) -> None: ...

    def setRowSelectionAllowed(self, __a0: bool) -> None: ...

    def setRowSelectionInterval(self, __a0: int, __a1: int) -> None: ...

    def setRowSorter(self, __a0: javax.swing.RowSorter) -> None: ...

    def setSelectionBackground(self, __a0: java.awt.Color) -> None: ...

    def setSelectionForeground(self, __a0: java.awt.Color) -> None: ...

    def setSelectionMode(self, __a0: int) -> None: ...

    def setSelectionModel(self, newModel: javax.swing.ListSelectionModel) -> None: ...

    def setShiftDown(self, isDown: bool) -> None:
        """
        Sets the status of the shift key.
        @param isDown
        """
        ...

    def setShowGrid(self, __a0: bool) -> None: ...

    def setShowHorizontalLines(self, __a0: bool) -> None: ...

    def setShowVerticalLines(self, __a0: bool) -> None: ...

    @overload
    def setSize(self, __a0: java.awt.Dimension) -> None: ...

    @overload
    def setSize(self, __a0: int, __a1: int) -> None: ...

    def setSurrendersFocusOnKeystroke(self, __a0: bool) -> None: ...

    def setTableHeader(self, __a0: javax.swing.table.JTableHeader) -> None: ...

    def setToolTipText(self, __a0: unicode) -> None: ...

    def setTransferHandler(self, __a0: javax.swing.TransferHandler) -> None: ...

    def setUI(self, __a0: javax.swing.plaf.TableUI) -> None: ...

    def setUpdateSelectionOnSort(self, __a0: bool) -> None: ...

    def setUserSortingEnabled(self, enabled: bool) -> None:
        """
        Allows for the disabling of the user's ability to sort an instance of
         {@link AbstractSortedTableModel} by clicking the table's headers.  The default setting is
         enabled.
        @param enabled true to enable; false to disable
        """
        ...

    def setValueAt(self, __a0: object, __a1: int, __a2: int) -> None: ...

    def setVerifyInputWhenFocusTarget(self, __a0: bool) -> None: ...

    def setVisible(self, __a0: bool) -> None: ...

    def setVisibleRowCount(self, visibleRowCount: int) -> None: ...

    @overload
    def show(self) -> None: ...

    @overload
    def show(self, __a0: bool) -> None: ...

    @overload
    def sizeColumnsToFit(self, __a0: int) -> None: ...

    @overload
    def sizeColumnsToFit(self, __a0: bool) -> None: ...

    def sorterChanged(self, __a0: javax.swing.event.RowSorterEvent) -> None: ...

    def tableChanged(self, e: javax.swing.event.TableModelEvent) -> None: ...

    def toString(self) -> unicode: ...

    def transferFocus(self) -> None: ...

    def transferFocusBackward(self) -> None: ...

    def transferFocusDownCycle(self) -> None: ...

    def transferFocusUpCycle(self) -> None: ...

    def unregisterKeyboardAction(self, __a0: javax.swing.KeyStroke) -> None: ...

    def update(self, __a0: java.awt.Graphics) -> None: ...

    def updateUI(self) -> None: ...

    def validate(self) -> None: ...

    def valueChanged(self, e: javax.swing.event.ListSelectionEvent) -> None:
        """
        Invoked when a new row has been selected in the table. Update our chunk model to
         reflect as much.
        @param e
        """
        ...

    @overload
    def wait(self) -> None: ...

    @overload
    def wait(self, __a0: long) -> None: ...

    @overload
    def wait(self, __a0: long, __a1: int) -> None: ...

    @property
    def mouseDragging(self) -> None: ...  # No getter available.

    @mouseDragging.setter
    def mouseDragging(self, value: bool) -> None: ...

    @property
    def shiftDown(self) -> None: ...  # No getter available.

    @shiftDown.setter
    def shiftDown(self, value: bool) -> None: ...
