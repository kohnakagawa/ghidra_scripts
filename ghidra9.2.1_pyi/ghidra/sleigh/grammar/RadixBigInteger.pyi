from typing import List
import java.lang
import java.util


class RadixBigInteger(long):
    location: ghidra.sleigh.grammar.Location



    @overload
    def __init__(self, location: ghidra.sleigh.grammar.Location, val: unicode): ...

    @overload
    def __init__(self, location: ghidra.sleigh.grammar.Location, val: List[int]): ...

    @overload
    def __init__(self, location: ghidra.sleigh.grammar.Location, val: unicode, radix: int): ...

    @overload
    def __init__(self, location: ghidra.sleigh.grammar.Location, signum: int, magnitude: List[int]): ...

    @overload
    def __init__(self, location: ghidra.sleigh.grammar.Location, numBits: int, rnd: java.util.Random): ...

    @overload
    def __init__(self, location: ghidra.sleigh.grammar.Location, bitLength: int, certainty: int, rnd: java.util.Random): ...



    def abs(self) -> long: ...

    def add(self, __a0: long) -> long: ...

    def and(self, __a0: long) -> long: ...

    def andNot(self, __a0: long) -> long: ...

    def bitCount(self) -> int: ...

    def bitLength(self) -> int: ...

    def byteValue(self) -> int: ...

    def byteValueExact(self) -> int: ...

    def clearBit(self, __a0: int) -> long: ...

    @overload
    def compareTo(self, __a0: long) -> int: ...

    @overload
    def compareTo(self, __a0: object) -> int: ...

    def divide(self, __a0: long) -> long: ...

    def divideAndRemainder(self, __a0: long) -> List[long]: ...

    def doubleValue(self) -> float: ...

    def equals(self, __a0: object) -> bool: ...

    def flipBit(self, __a0: int) -> long: ...

    def floatValue(self) -> float: ...

    def gcd(self, __a0: long) -> long: ...

    def getClass(self) -> java.lang.Class: ...

    def getLowestSetBit(self) -> int: ...

    def getPreferredRadix(self) -> int: ...

    def hashCode(self) -> int: ...

    def intValue(self) -> int: ...

    def intValueExact(self) -> int: ...

    def isProbablePrime(self, __a0: int) -> bool: ...

    def longValue(self) -> long: ...

    def longValueExact(self) -> long: ...

    def max(self, __a0: long) -> long: ...

    def min(self, __a0: long) -> long: ...

    def mod(self, __a0: long) -> long: ...

    def modInverse(self, __a0: long) -> long: ...

    def modPow(self, __a0: long, __a1: long) -> long: ...

    def multiply(self, __a0: long) -> long: ...

    def negate(self) -> long: ...

    def nextProbablePrime(self) -> long: ...

    def not(self) -> long: ...

    def notify(self) -> None: ...

    def notifyAll(self) -> None: ...

    def or(self, __a0: long) -> long: ...

    def pow(self, __a0: int) -> long: ...

    @staticmethod
    def probablePrime(__a0: int, __a1: java.util.Random) -> long: ...

    def remainder(self, __a0: long) -> long: ...

    def setBit(self, __a0: int) -> long: ...

    def setPreferredRadix(self, preferredRadix: int) -> None: ...

    def shiftLeft(self, __a0: int) -> long: ...

    def shiftRight(self, __a0: int) -> long: ...

    def shortValue(self) -> int: ...

    def shortValueExact(self) -> int: ...

    def signum(self) -> int: ...

    def sqrt(self) -> long: ...

    def sqrtAndRemainder(self) -> List[long]: ...

    def subtract(self, __a0: long) -> long: ...

    def testBit(self, __a0: int) -> bool: ...

    def toByteArray(self) -> List[int]: ...

    @overload
    def toString(self) -> unicode: ...

    @overload
    def toString(self, __a0: int) -> unicode: ...

    @staticmethod
    def valueOf(__a0: long) -> long: ...

    @overload
    def wait(self) -> None: ...

    @overload
    def wait(self, __a0: long) -> None: ...

    @overload
    def wait(self, __a0: long, __a1: int) -> None: ...

    def xor(self, __a0: long) -> long: ...

    @property
    def preferredRadix(self) -> int: ...

    @preferredRadix.setter
    def preferredRadix(self, value: int) -> None: ...
