from typing import List
import ghidra.app.plugin.processors.generic
import ghidra.program.model.address
import ghidra.program.model.lang
import ghidra.program.model.listing
import ghidra.program.model.mem
import ghidra.program.model.util
import ghidra.util
import ghidra.util.task
import java.lang
import java.util


class OldLanguage(object, ghidra.program.model.lang.Language):








    def applyContextSettings(self, ctx: ghidra.program.model.listing.DefaultProgramContext) -> None: ...

    def equals(self, __a0: object) -> bool: ...

    def getAddressFactory(self) -> ghidra.program.model.address.AddressFactory: ...

    def getClass(self) -> java.lang.Class: ...

    def getCompatibleCompilerSpecDescriptions(self) -> List[ghidra.program.model.lang.CompilerSpecDescription]: ...

    def getCompilerSpecByID(self, compilerSpecID: ghidra.program.model.lang.CompilerSpecID) -> ghidra.program.model.lang.CompilerSpec: ...

    def getContextBaseRegister(self) -> ghidra.program.model.lang.Register: ...

    def getContextRegisters(self) -> List[ghidra.program.model.lang.Register]: ...

    def getDefaultCompilerSpec(self) -> ghidra.program.model.lang.CompilerSpec: ...

    def getDefaultDataSpace(self) -> ghidra.program.model.address.AddressSpace: ...

    def getDefaultMemoryBlocks(self) -> List[ghidra.app.plugin.processors.generic.MemoryBlockDefinition]: ...

    def getDefaultSpace(self) -> ghidra.program.model.address.AddressSpace: ...

    def getDefaultSymbols(self) -> List[ghidra.program.model.util.AddressLabelInfo]: ...

    def getInstructionAlignment(self) -> int: ...

    def getLanguageDescription(self) -> ghidra.program.model.lang.LanguageDescription: ...

    def getLanguageID(self) -> ghidra.program.model.lang.LanguageID: ...

    def getManualEntry(self, instructionMnemonic: unicode) -> ghidra.util.ManualEntry: ...

    def getManualException(self) -> java.lang.Exception: ...

    def getManualInstructionMnemonicKeys(self) -> java.util.Set: ...

    def getMinorVersion(self) -> int: ...

    def getNumberOfUserDefinedOpNames(self) -> int: ...

    def getParallelInstructionHelper(self) -> ghidra.program.model.lang.ParallelInstructionLanguageHelper: ...

    def getProcessor(self) -> ghidra.program.model.lang.Processor: ...

    def getProgramCounter(self) -> ghidra.program.model.lang.Register: ...

    @overload
    def getProperty(self, key: unicode) -> unicode: ...

    @overload
    def getProperty(self, key: unicode, defaultString: unicode) -> unicode: ...

    def getPropertyAsBoolean(self, key: unicode, defaultBoolean: bool) -> bool: ...

    def getPropertyAsInt(self, key: unicode, defaultInt: int) -> int: ...

    def getPropertyKeys(self) -> java.util.Set: ...

    @overload
    def getRegister(self, name: unicode) -> ghidra.program.model.lang.Register: ...

    @overload
    def getRegister(self, addr: ghidra.program.model.address.Address, size: int) -> ghidra.program.model.lang.Register: ...

    @overload
    def getRegister(self, addrspc: ghidra.program.model.address.AddressSpace, offset: long, size: int) -> ghidra.program.model.lang.Register: ...

    def getRegisterNames(self) -> List[unicode]: ...

    @overload
    def getRegisters(self) -> List[ghidra.program.model.lang.Register]: ...

    @overload
    def getRegisters(self, address: ghidra.program.model.address.Address) -> List[ghidra.program.model.lang.Register]: ...

    def getSegmentedSpace(self) -> unicode: ...

    def getSortedVectorRegisters(self) -> List[ghidra.program.model.lang.Register]: ...

    def getUserDefinedOpName(self, index: int) -> unicode: ...

    def getVersion(self) -> int: ...

    def getVolatileAddresses(self) -> ghidra.program.model.address.AddressSetView: ...

    def hasManual(self) -> bool: ...

    def hasProperty(self, key: unicode) -> bool: ...

    def hashCode(self) -> int: ...

    def isBigEndian(self) -> bool: ...

    def isVolatile(self, addr: ghidra.program.model.address.Address) -> bool: ...

    def notify(self) -> None: ...

    def notifyAll(self) -> None: ...

    def parse(self, buf: ghidra.program.model.mem.MemBuffer, context: ghidra.program.model.lang.ProcessorContext, inDelaySlot: bool) -> ghidra.program.model.lang.InstructionPrototype: ...

    def reloadLanguage(self, taskMonitor: ghidra.util.task.TaskMonitor) -> None: ...

    def supportsPcode(self) -> bool: ...

    def toString(self) -> unicode: ...

    @overload
    def wait(self) -> None: ...

    @overload
    def wait(self, __a0: long) -> None: ...

    @overload
    def wait(self, __a0: long, __a1: int) -> None: ...
