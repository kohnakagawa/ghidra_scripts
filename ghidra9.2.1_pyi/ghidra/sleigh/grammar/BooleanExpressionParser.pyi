from typing import List
import java.lang
import org.antlr.runtime


class BooleanExpressionParser(org.antlr.runtime.Parser):
    ALPHA: int = 4
    DIGIT: int = 5
    EOF: int = -1
    ESCAPE: int = 6
    FOLLOW_20_in_expr_not261: org.antlr.runtime.BitSet = {8}
    FOLLOW_20_in_expr_paren284: org.antlr.runtime.BitSet = {8,9,14,17,20}
    FOLLOW_21_in_expr_not267: org.antlr.runtime.BitSet = {1}
    FOLLOW_21_in_expr_paren290: org.antlr.runtime.BitSet = {1}
    FOLLOW_EOF_in_expression87: org.antlr.runtime.BitSet = {1}
    FOLLOW_IDENTIFIER_in_expr_not265: org.antlr.runtime.BitSet = {21}
    FOLLOW_IDENTIFIER_in_expr_term350: org.antlr.runtime.BitSet = {1}
    FOLLOW_KEY_DEFINED_in_expr_not259: org.antlr.runtime.BitSet = {20}
    FOLLOW_OP_AND_in_expr_and190: org.antlr.runtime.BitSet = {8,9,14,17,20}
    FOLLOW_OP_EQ_in_expr_eq311: org.antlr.runtime.BitSet = {8,17}
    FOLLOW_OP_NEQ_in_expr_eq327: org.antlr.runtime.BitSet = {8,17}
    FOLLOW_OP_NOT_in_expr_not213: org.antlr.runtime.BitSet = {20}
    FOLLOW_OP_OR_in_expr_or130: org.antlr.runtime.BitSet = {8,9,14,17,20}
    FOLLOW_OP_XOR_in_expr_xor160: org.antlr.runtime.BitSet = {8,9,14,17,20}
    FOLLOW_QSTRING_in_expr_term359: org.antlr.runtime.BitSet = {1}
    FOLLOW_expr_and_in_expr_xor155: org.antlr.runtime.BitSet = {1,16}
    FOLLOW_expr_and_in_expr_xor164: org.antlr.runtime.BitSet = {1,16}
    FOLLOW_expr_eq_in_expr_not242: org.antlr.runtime.BitSet = {1}
    FOLLOW_expr_in_expr_paren288: org.antlr.runtime.BitSet = {21}
    FOLLOW_expr_in_expression85: org.antlr.runtime.BitSet = {}
    FOLLOW_expr_not_in_expr_and185: org.antlr.runtime.BitSet = {1,11}
    FOLLOW_expr_not_in_expr_and194: org.antlr.runtime.BitSet = {1,11}
    FOLLOW_expr_or_in_expr106: org.antlr.runtime.BitSet = {1}
    FOLLOW_expr_paren_in_expr_not217: org.antlr.runtime.BitSet = {1}
    FOLLOW_expr_paren_in_expr_not226: org.antlr.runtime.BitSet = {1}
    FOLLOW_expr_term_in_expr_eq309: org.antlr.runtime.BitSet = {12}
    FOLLOW_expr_term_in_expr_eq315: org.antlr.runtime.BitSet = {1}
    FOLLOW_expr_term_in_expr_eq325: org.antlr.runtime.BitSet = {13}
    FOLLOW_expr_term_in_expr_eq331: org.antlr.runtime.BitSet = {1}
    FOLLOW_expr_xor_in_expr_or125: org.antlr.runtime.BitSet = {1,15}
    FOLLOW_expr_xor_in_expr_or134: org.antlr.runtime.BitSet = {1,15}
    HEXDIGIT: int = 7
    IDENTIFIER: int = 8
    KEY_DEFINED: int = 9
    OCTAL_ESCAPE: int = 10
    OP_AND: int = 11
    OP_EQ: int = 12
    OP_NEQ: int = 13
    OP_NOT: int = 14
    OP_OR: int = 15
    OP_XOR: int = 16
    QSTRING: int = 17
    T__20: int = 20
    T__21: int = 21
    UNICODE_ESCAPE: int = 18
    WS: int = 19
    env: ghidra.sleigh.grammar.ExpressionEnvironment
    input: org.antlr.runtime.TokenStream



    @overload
    def __init__(self, input: org.antlr.runtime.TokenStream): ...

    @overload
    def __init__(self, input: org.antlr.runtime.TokenStream, state: org.antlr.runtime.RecognizerSharedState): ...



    def alreadyParsedRule(self, __a0: org.antlr.runtime.IntStream, __a1: int) -> bool: ...

    def beginResync(self) -> None: ...

    @overload
    def consumeUntil(self, __a0: org.antlr.runtime.IntStream, __a1: int) -> None: ...

    @overload
    def consumeUntil(self, __a0: org.antlr.runtime.IntStream, __a1: org.antlr.runtime.BitSet) -> None: ...

    def displayRecognitionError(self, __a0: List[unicode], __a1: org.antlr.runtime.RecognitionException) -> None: ...

    def emitErrorMessage(self, __a0: unicode) -> None: ...

    def endResync(self) -> None: ...

    def equals(self, __a0: object) -> bool: ...

    def expr(self) -> bool: ...

    def expr_and(self) -> bool: ...

    def expr_eq(self) -> bool: ...

    def expr_not(self) -> bool: ...

    def expr_or(self) -> bool: ...

    def expr_paren(self) -> bool: ...

    def expr_term(self) -> unicode: ...

    def expr_xor(self) -> bool: ...

    def expression(self) -> bool: ...

    def failed(self) -> bool: ...

    def getBacktrackingLevel(self) -> int: ...

    def getClass(self) -> java.lang.Class: ...

    def getDelegates(self) -> List[org.antlr.runtime.Parser]: ...

    def getErrorHeader(self, __a0: org.antlr.runtime.RecognitionException) -> unicode: ...

    def getErrorMessage(self, __a0: org.antlr.runtime.RecognitionException, __a1: List[unicode]) -> unicode: ...

    def getGrammarFileName(self) -> unicode: ...

    def getNumberOfSyntaxErrors(self) -> int: ...

    @overload
    def getRuleInvocationStack(self) -> List[object]: ...

    @overload
    @staticmethod
    def getRuleInvocationStack(__a0: java.lang.Throwable, __a1: unicode) -> List[object]: ...

    def getRuleMemoization(self, __a0: int, __a1: int) -> int: ...

    def getRuleMemoizationCacheSize(self) -> int: ...

    def getSourceName(self) -> unicode: ...

    def getTokenErrorDisplay(self, __a0: org.antlr.runtime.Token) -> unicode: ...

    def getTokenNames(self) -> List[unicode]: ...

    def getTokenStream(self) -> org.antlr.runtime.TokenStream: ...

    def hashCode(self) -> int: ...

    @staticmethod
    def main(args: List[unicode]) -> None: ...

    def match(self, __a0: org.antlr.runtime.IntStream, __a1: int, __a2: org.antlr.runtime.BitSet) -> object: ...

    def matchAny(self, __a0: org.antlr.runtime.IntStream) -> None: ...

    def memoize(self, __a0: org.antlr.runtime.IntStream, __a1: int, __a2: int) -> None: ...

    def mismatchIsMissingToken(self, __a0: org.antlr.runtime.IntStream, __a1: org.antlr.runtime.BitSet) -> bool: ...

    def mismatchIsUnwantedToken(self, __a0: org.antlr.runtime.IntStream, __a1: int) -> bool: ...

    def notify(self) -> None: ...

    def notifyAll(self) -> None: ...

    def recover(self, __a0: org.antlr.runtime.IntStream, __a1: org.antlr.runtime.RecognitionException) -> None: ...

    def recoverFromMismatchedSet(self, __a0: org.antlr.runtime.IntStream, __a1: org.antlr.runtime.RecognitionException, __a2: org.antlr.runtime.BitSet) -> object: ...

    def reportError(self, __a0: org.antlr.runtime.RecognitionException) -> None: ...

    def reset(self) -> None: ...

    def setBacktrackingLevel(self, __a0: int) -> None: ...

    def setTokenStream(self, __a0: org.antlr.runtime.TokenStream) -> None: ...

    def toString(self) -> unicode: ...

    def toStrings(self, __a0: List[object]) -> List[object]: ...

    @overload
    def traceIn(self, __a0: unicode, __a1: int) -> None: ...

    @overload
    def traceIn(self, __a0: unicode, __a1: int, __a2: object) -> None: ...

    @overload
    def traceOut(self, __a0: unicode, __a1: int) -> None: ...

    @overload
    def traceOut(self, __a0: unicode, __a1: int, __a2: object) -> None: ...

    @overload
    def wait(self) -> None: ...

    @overload
    def wait(self, __a0: long) -> None: ...

    @overload
    def wait(self, __a0: long, __a1: int) -> None: ...

    @property
    def delegates(self) -> List[org.antlr.runtime.Parser]: ...

    @property
    def grammarFileName(self) -> unicode: ...

    @property
    def tokenNames(self) -> List[unicode]: ...
