from typing import Iterator
import com.google.common.base
import edu.uci.ics.jung.graph.util
import ghidra.graph
import ghidra.graph.event
import ghidra.graph.graphs
import ghidra.graph.viewer
import ghidra.graph.viewer.layout
import java.awt
import java.lang
import java.util


class FilteringVisualGraph(ghidra.graph.graphs.DefaultVisualGraph):
    """
    A graph implementation that allows clients to mark vertices and edges as filtered.  When
     filtered, a vertex is removed from this graph, but kept around for later unfiltering. Things
     of note:

     		As vertices are filtered, so to will be their edges

     		If additions are made to the graph while it is filtered, the new additions will
              not be added to the current graph, but will be kept in the background for later
              restoring





     Implementation Note: this class engages in some odd behavior when removals and additions
     are need to this graph.  A distinction is made between events that are generated from
     external clients and those that happen due to filtering and restoring.  This distinction
     allows this class to know when to update this graph, based upon whether or not data has
     been filtered.   Implementation of this is achieved by using a flag.  Currently, this flag
     is thread-safe.  If this graph is to be multi-threaded (such as if changes are to be
     made by multiple threads, then this update flag will have to be revisited to ensure thread
     visibility.
    """





    def __init__(self): ...



    @overload
    def addEdge(self, __a0: ghidra.graph.viewer.VisualEdge) -> None: ...

    @overload
    def addEdge(self, __a0: ghidra.graph.GEdge) -> None: ...

    @overload
    def addEdge(self, __a0: ghidra.graph.viewer.VisualEdge, __a1: edu.uci.ics.jung.graph.util.Pair) -> bool: ...

    @overload
    def addEdge(self, __a0: object, __a1: edu.uci.ics.jung.graph.util.Pair) -> bool: ...

    @overload
    def addEdge(self, __a0: ghidra.graph.viewer.VisualEdge, __a1: java.util.Collection) -> bool: ...

    @overload
    def addEdge(self, __a0: object, __a1: java.util.Collection) -> bool: ...

    @overload
    def addEdge(self, __a0: ghidra.graph.viewer.VisualEdge, __a1: edu.uci.ics.jung.graph.util.Pair, __a2: edu.uci.ics.jung.graph.util.EdgeType) -> bool: ...

    @overload
    def addEdge(self, __a0: ghidra.graph.viewer.VisualEdge, __a1: ghidra.graph.viewer.VisualVertex, __a2: ghidra.graph.viewer.VisualVertex) -> bool: ...

    @overload
    def addEdge(self, __a0: object, __a1: edu.uci.ics.jung.graph.util.Pair, __a2: edu.uci.ics.jung.graph.util.EdgeType) -> bool: ...

    @overload
    def addEdge(self, __a0: ghidra.graph.viewer.VisualEdge, __a1: java.util.Collection, __a2: edu.uci.ics.jung.graph.util.EdgeType) -> bool: ...

    @overload
    def addEdge(self, __a0: object, __a1: java.util.Collection, __a2: edu.uci.ics.jung.graph.util.EdgeType) -> bool: ...

    @overload
    def addEdge(self, __a0: object, __a1: object, __a2: object) -> bool: ...

    @overload
    def addEdge(self, __a0: ghidra.graph.viewer.VisualEdge, __a1: ghidra.graph.viewer.VisualVertex, __a2: ghidra.graph.viewer.VisualVertex, __a3: edu.uci.ics.jung.graph.util.EdgeType) -> bool: ...

    @overload
    def addEdge(self, __a0: object, __a1: object, __a2: object, __a3: edu.uci.ics.jung.graph.util.EdgeType) -> bool: ...

    def addGraphChangeListener(self, l: ghidra.graph.event.VisualGraphChangeListener) -> None: ...

    @overload
    def addVertex(self, __a0: ghidra.graph.viewer.VisualVertex) -> bool: ...

    @overload
    def addVertex(self, __a0: object) -> bool: ...

    def clearFilter(self) -> None: ...

    def clearSelectedVertices(self) -> None: ...

    @overload
    def containsEdge(self, __a0: ghidra.graph.GEdge) -> bool: ...

    @overload
    def containsEdge(self, __a0: object) -> bool: ...

    @overload
    def containsEdge(self, __a0: object, __a1: object) -> bool: ...

    def containsVertex(self, __a0: object) -> bool: ...

    def copy(self) -> ghidra.graph.graphs.DefaultVisualGraph: ...

    def degree(self, __a0: object) -> int: ...

    def dispose(self) -> None: ...

    def emptyCopy(self) -> ghidra.graph.GDirectedGraph: ...

    def equals(self, __a0: object) -> bool: ...

    def filterEdges(self, toFilter: java.util.Collection) -> None: ...

    def filterVertices(self, toFilter: java.util.Collection) -> None: ...

    def findEdge(self, __a0: object, __a1: object) -> object: ...

    def findEdgeSet(self, __a0: object, __a1: object) -> java.util.Collection: ...

    @overload
    def getAllEdges(self) -> Iterator[E]: ...

    @overload
    def getAllEdges(self, __a0: ghidra.graph.viewer.VisualVertex) -> java.lang.Iterable: ...

    @overload
    def getAllEdges(self, sourceVertices: java.util.Set) -> java.util.Set:
        """
        Returns all edges connected to the given vertices.

         <P>This method is needed if you wish to find relationships that have been filtered
         out.
        @param sourceVertices the vertices for which to get the edges
        @return the reachable edges
        """
        ...

    def getAllReachableVertices(self, sourceVertices: java.util.Set) -> java.util.Set:
        """
        Returns all vertices that are reachable by the given vertices.

         <P>This method is needed if you wish to find relationships that have been filtered
         out.
        @param sourceVertices the vertices for which to find the other reachable vertices
        @return the reachable vertices
        """
        ...

    def getAllVertices(self) -> Iterator[V]: ...

    def getClass(self) -> java.lang.Class: ...

    def getDefaultEdgeType(self) -> edu.uci.ics.jung.graph.util.EdgeType: ...

    def getDest(self, __a0: object) -> object: ...

    @overload
    def getEdgeCount(self) -> int: ...

    @overload
    def getEdgeCount(self, __a0: edu.uci.ics.jung.graph.util.EdgeType) -> int: ...

    def getEdgeType(self, __a0: object) -> edu.uci.ics.jung.graph.util.EdgeType: ...

    @overload
    def getEdges(self) -> java.util.Collection: ...

    @overload
    def getEdges(self, __a0: edu.uci.ics.jung.graph.util.EdgeType) -> java.util.Collection: ...

    @overload
    def getEdges(self, __a0: ghidra.graph.viewer.VisualVertex, __a1: ghidra.graph.viewer.VisualVertex) -> java.lang.Iterable: ...

    def getEndpoints(self, __a0: object) -> edu.uci.ics.jung.graph.util.Pair: ...

    @staticmethod
    def getFactory() -> com.google.common.base.Supplier: ...

    def getFilteredEdges(self) -> Iterator[E]: ...

    def getFilteredVertices(self) -> Iterator[V]: ...

    def getFocusedVertex(self) -> V: ...

    def getInEdges(self, __a0: object) -> java.util.Collection: ...

    def getIncidentCount(self, __a0: object) -> int: ...

    def getIncidentEdges(self, __a0: object) -> java.util.Collection: ...

    def getIncidentVertices(self, __a0: object) -> java.util.Collection: ...

    def getLayout(self) -> ghidra.graph.viewer.layout.VisualGraphLayout: ...

    def getNeighborCount(self, __a0: object) -> int: ...

    def getNeighbors(self, __a0: object) -> java.util.Collection: ...

    def getOpposite(self, __a0: object, __a1: object) -> object: ...

    def getOutEdges(self, __a0: object) -> java.util.Collection: ...

    def getPredecessorCount(self, __a0: object) -> int: ...

    def getPredecessors(self, __a0: object) -> java.util.Collection: ...

    def getSelectedVertices(self) -> java.util.Set: ...

    def getSource(self, __a0: object) -> object: ...

    def getSuccessorCount(self, __a0: object) -> int: ...

    def getSuccessors(self, __a0: object) -> java.util.Collection: ...

    def getUnfilteredEdges(self) -> Iterator[E]: ...

    def getUnfilteredVertices(self) -> Iterator[V]: ...

    def getVertexCount(self) -> int: ...

    def getVertices(self) -> java.util.Collection: ...

    def hashCode(self) -> int: ...

    def inDegree(self, __a0: object) -> int: ...

    def isDest(self, __a0: object, __a1: object) -> bool: ...

    def isEmpty(self) -> bool: ...

    def isFiltered(self) -> bool: ...

    def isIncident(self, __a0: object, __a1: object) -> bool: ...

    def isNeighbor(self, __a0: object, __a1: object) -> bool: ...

    def isPredecessor(self, __a0: object, __a1: object) -> bool: ...

    def isSource(self, __a0: object, __a1: object) -> bool: ...

    def isSuccessor(self, __a0: object, __a1: object) -> bool: ...

    def notify(self) -> None: ...

    def notifyAll(self) -> None: ...

    def outDegree(self, __a0: object) -> int: ...

    @overload
    def removeEdge(self, __a0: ghidra.graph.viewer.VisualEdge) -> bool: ...

    @overload
    def removeEdge(self, __a0: ghidra.graph.GEdge) -> bool: ...

    @overload
    def removeEdge(self, __a0: object) -> bool: ...

    def removeEdges(self, toRemove: java.lang.Iterable) -> None: ...

    def removeGraphChangeListener(self, l: ghidra.graph.event.VisualGraphChangeListener) -> None: ...

    @overload
    def removeVertex(self, __a0: ghidra.graph.viewer.VisualVertex) -> bool: ...

    @overload
    def removeVertex(self, __a0: object) -> bool: ...

    def removeVertices(self, verticesToRemove: java.lang.Iterable) -> None: ...

    def setSelectedVertices(self, selectedVertices: java.util.Set) -> None: ...

    def setVertexFocused(self, __a0: ghidra.graph.viewer.VisualVertex, __a1: bool) -> None: ...

    def toString(self) -> unicode: ...

    def unfilterEdges(self, toUnfilter: java.util.Collection) -> None:
        """
        Restores the given filtered edges into the graph.  This will only happen if both
         endpoints are in the graph.
        @param toUnfilter the edges to restore
        """
        ...

    def unfilterVertices(self, toUnfilter: java.util.Collection) -> None:
        """
        Restores the given filtered vertices into the graph.  This will only happen if both
         endpoints are in the graph.
        @param toUnfilter the edges to restore
        """
        ...

    def vertexLocationChanged(self, __a0: ghidra.graph.viewer.VisualVertex, __a1: java.awt.Point, __a2: ghidra.graph.viewer.layout.LayoutListener.ChangeType) -> None: ...

    @overload
    def wait(self) -> None: ...

    @overload
    def wait(self, __a0: long) -> None: ...

    @overload
    def wait(self, __a0: long, __a1: int) -> None: ...

    @property
    def allEdges(self) -> java.util.Iterator: ...

    @property
    def allVertices(self) -> java.util.Iterator: ...

    @property
    def filtered(self) -> bool: ...

    @property
    def filteredEdges(self) -> java.util.Iterator: ...

    @property
    def filteredVertices(self) -> java.util.Iterator: ...

    @property
    def unfilteredEdges(self) -> java.util.Iterator: ...

    @property
    def unfilteredVertices(self) -> java.util.Iterator: ...
